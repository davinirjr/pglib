<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="pglib : A simple Python 3.3+ library for PostgreSQL based on libpq" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/toc.css">

    <title>pglib</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/mkleehammer/pglib">View on GitHub</a>

          <h1 id="project_title">pglib</h1>
          <h2 id="project_tagline">A simple Python 3.3+ library for PostgreSQL based on libpq</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/mkleehammer/pglib/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/mkleehammer/pglib/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">

      <ul class="toc">
        <li><a href="#welcome-to-pglib">Welcome to pglib</a></li>
        <li><a href="#quick-start">Quick Start</a></li>
        <li>
          <ul class="toc">
            <li><a href="#installing">Installing</a></li>
            <li><a href="#connecting">Connecting</a></li>
            <li><a href="#selection-basics">Selection Basics</a></li>
            <li><a href="#parameters">Parameters</a></li>
          </ul>
        </li>
      </ul>

<h2>
<a name="welcome-to-pglib" class="anchor" href="#welcome-to-pglib"><span class="octicon octicon-link"></span></a>Welcome to pglib</h2>

<p>pglib is a Python 3.3+ module for working with PostgreSQL databases.  It is a C extension
that exposes the <a href="http://www.postgresql.org/docs/9.3/static/libpq.html">libpq</a> API.
It is designed to be small, fast, and as convenient as possible.</p>

<h2>
<a name="quick-start" class="anchor" href="#quick-start"><span class="octicon octicon-link"></span></a>Quick Start</h2>

<p>While this documentation is being written, the best place to learn about pglib is its
<a href="https://github.com/mkleehammer/pglib/blob/master/tests">unit tests file</a> which has
examples of every feature.</p>

<h3>
<a name="installing" class="anchor" href="#installing"><span class="octicon octicon-link"></span></a>Installing</h3>

<p><a href="https://github.com/mkleehammer/pglib/releases">Pre-built binaries</a> are
available for OS/X and Windows 64-bit Python.  To build your own binary see
<a href="building.html">building pglib</a>.</p>

<h3>
<a name="connecting" class="anchor" href="#connecting"><span class="octicon octicon-link"></span></a>Connecting</h3>

To connect, pass a <a href="http://www.postgresql.org/docs/9.3/static/libpq-connect.html#LIBPQ-CONNSTRING">
libpq connection string</a> to the pglib.connect function.

<pre>
import pglib
cnxn = pglib.connect('host=localhost dbname=test')
</pre>

<h3>
<a name="selection-basics" class="anchor" href="#selection-basics"><span class="octicon octicon-link"></span></a>Selection Basics</h3>

<p>Connection.execute accepts a SQL statement and optional parameters and returns a ResultSet.
If the SQL was a select statement, ResultSet.columns will be a tuple containing the resulting
column names and act as a collection of the resulting Row objects.  The Row objects can be
accessed by indexing into the ResultSet or iterating over it.</p> <pre> rset =
cnxn.execute("select id, name from users")

print('columns:', rset.columns) # ('id', 'name')

print('count:', len(rset))
print('first:', rset[0])

for row in rset:
    print(row)
</pre>

<p>The design of libpq, PostgreSQL's client library, means that all row data is kept in memory
while the ResultSet exists.  This means that result sets can be iterated over multiple times.
It also means large result sets should be discarded as soon as possible.</p>

<p>Row objects are similar to tuples, but they also allow access to columns by name.</p>

<pre>
rset = cnxn.execute("select id, name from users limit 1")
row = rset[0]
print('id:', row[0]) # access id by column index
print('id:', row.id) # access id by column name
</pre>

<p>The SQL 'as' keyword makes it easy to set the name.</p>

<pre>
rset = cnxn.execute("select count(*) as cnt from users")
row = rset[0]
print(row.cnt)
</pre>

<p>The Connection.row method is a convenience method that returns the first result Row.  If
there are no results it returns None.</p>

<pre>
row = cnxn.row("select count(*) as cnt from users")
print(row.cnt)
</pre>

<p>The Connection.scalar method, another convenience method, returns the first column of the
first row.  If there are no results it returns None.</p>

<pre>
count = cnxn.scalar("select count(*) from users")
print(count)
</pre>

<p>Each row is a Python sequence, so it can be used in many places that a tuple or list can.
To convert the values into a tuple use <code>tuple(row)</code>.</p>

<p>Finally, to make it convenient to pass a Row around to functions, the columns are also available
from the row object.  Note that a column actually named 'columns' will override this.</p>

<pre>
print('columns:', row.columns)

# Convert to dictionary:
d = dict(zip(row.columns, row))
</pre>

<h3>
<a name="parameters" class="anchor" href="#parameters"><span class="octicon octicon-link"></span></a>Parameters</h3>
    
<p>PostgreSQL supports parameters using $1, $2, etc. as a place holder in the SQL.  Values for these
are passed after the SQL.  The first parameter passed is used for $1, the second for $2, etc.</p>

<pre>
cnxn.execute("""
             select id, name
               from users
              where id > $1
                    and bill_overdue = $2
             """, 100, 1)  # 100 -> $1, 1 -> $2
</pre>

<p>Parameters are always passed to the server separately from the SQL statement and pglib never
modifies the SQL passed to it.  You should <em>always</em> pass parameters separately to
protect against <a href="http://en.wikipedia.org/wiki/SQL_injection">SQL injection attacks</a>.</p>

</p>

<p>Right now there is a limited set of data types accepted.  Feel free to open an
<a href="https://github.com/mkleehammer/pglib/issues">issue</a> to request new ones.</p>

<table>
  <thead>
    <tr><th>Python Type</th><th>SQL Type</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>None</td>
      <td>NULL</td>
    </tr>
    <tr>
      <td>bool</td>
      <td>Boolean</td>
    </tr>
    <tr>
      <td>bytes</td>
      <td>binary</td>
    </tr>
    <tr>
      <td>bytearray</td>
      <td>binary</td>
    </tr>
    <tr>
      <td>datetime.date</td>
      <td>date</td>
    </tr>
    <tr>
      <td>datetime.datetime</td>
      <td>timestamp</td>
    </tr>
    <tr>
      <td>datetime.time</td>
      <td>time</td>
    </tr>
    <tr>
      <td>decimal.Decimal</td>
      <td>numeric</td>
    </tr>
    <tr>
      <td>float</td>
      <td>float8</td>
    </tr>
    <tr>
      <td>int</td>
      <td>int64 or numeric</td>
    </tr>
    <tr>
      <td>str</td>
      <td>text encoded as UTF-8</td>
    </tr>
    <tr>
      <td>uuid.UUID</td>
      <td>uuid</td>
    </tr>
  </tbody>
</table>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">pglib maintained by <a href="https://github.com/mkleehammer">mkleehammer</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>


  </body>
</html>
